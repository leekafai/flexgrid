## 问题
- 拖动时指针跟随的“蓝色框”尺寸与原卡片不一致：影子尺寸按单位格推算，而非实际 DOM 尺寸。
- 第一行的卡片无法拖到其他行：当指针不位于某张卡片上时，插入索引仅回落到末尾，未根据指针的 Y 坐标映射到对应行。

## 方案
1. 精确影子尺寸
- 在 `startDrag/updateDrag` 中测量被拖卡片的实际 `getBoundingClientRect()` 尺寸并缓存 `dragSize`
- `getDragStyles` 使用 `dragSize`，保证影子与原卡片一致（含圆角与当前样式）

2. 跨行插入索引
- 当未命中任何卡片时，用指针的 `clientY` 与每个子卡片的 `rect.top/height` 计算插入索引：选择“最后一个中心点在指针 Y 之上的卡片”之后的位置
- 这样可以在分散排布下仍能根据 Y 位置插入到对应行

3. 预估位置矩形
- 将 `dropRect` 的宽高也使用测量得到的 `dragSize`，匹配被拖卡片真实尺寸
- 保留容器边界钳制与 rAF 节流

## 实施点
- `src/composables/useDragAndDrop.ts`：新增 `dragSize`，更新 `startDrag/updateDrag/getDragStyles`，改进索引计算逻辑与 `dropRect`

## 验证
- 在 `/test` 页面，拖动不同大小卡片，蓝色影子尺寸应与原卡片一致；在第一行拖向下方空白处能插入到下一行。