## 目标原则
- 仅在“当前阴影位置”触发一次避让；阴影未变则节流；阴影变化则重新计算并应用新避让。
- 避让始终以阴影为准（非鼠标），只对阴影覆盖的卡片进行；一次只移动一张卡；保持拖拽期间不重叠。

## 阴影变化检测
- 状态缓存 `prevShadowState = { areaKey, left, top, coveredIds }`。
- 每帧（RAF）计算：
  - `areaKey = gridRect(x,y,w,h)` 来自 `dropRect` → `toGridXY`
  - 像素阈值：`|left-prev.left| < 5 && |top-prev.top| < 5`
  - 覆盖集合：用阴影像素矩形与卡片像素矩形做 AABB 得到 `coveredIds`
- 节流条件：像素未变 + `areaKey` 未变 + `coveredIds` 未变 → 跳过；否则进入避让计算。

## 单次避让与会话最小持有
- 维护 `activeAreaKey` 与 `activeTarget { cardId, origPos, movedPos }`：
  - 初次在该 `areaKey` 触发避让时，选择重叠面积最大的卡，计算四向位置并移动；记录 `activeTarget`。
  - 阴影仍在同 `areaKey` 时不重复移动（节流）；
  - 阴影切换到新 `areaKey` 时：
    - 若 `activeTarget.cardId` 不在新 `coveredIds`，先还原其到 `origPos`；
    - 然后按新 `coveredIds` 重新选择并避让；更新 `activeAreaKey/activeTarget`。
- 不引入复杂的全局预留图，仅在“同一区域”持有一次避让，阴影变更后立即按覆盖集合重算（满足你“只避让一次，但阴影变更要重算”的要求）。

## 四向检查与回退
- 可用空间检测：
  - 单步探测顺序：下→右→上→左；
  - 若单步不可用，使用限深 BFS（方向优先下→右→上→左；最大节点/层数限制，行越界视为可扩展空行，允许向下）。
- 选卡策略：按与阴影重叠面积降序；同面积时选择位移成本最小。
- 用户松手：若最终仍冲突（无可避让），拖拽卡平滑复位到原始位置（≤300ms）。

## DOM Diff 与稳定性
- 记录 `lastMoves`；若本次目标与上次一致则不下发 DOM 操作。
- 动画统一 220–300ms，`cubic-bezier(.22,1,.36,1)`；禁用 `left/top` 过渡避免错误来源动画。

## 集成改动
- 插件：
  - 增加 `prevShadowState/activeAreaKey/activeTarget/lastMoves`；
  - 在 `onDragUpdate` 执行“阴影变化检测 → 单次避让 → DOM Diff”；
  - 在 `onBeforeDrop` 强制最终避让或还原；在 `onDragEnd` 清理状态。
- 网格：保留现有调用；应用返回计划时只移动变化的卡；落点时先避让，再“复位或提交”。

## 测试与验收
- 阴影停留于卡 A：只移动一次；同区域内移动不重复；
- 阴影转移到卡 B：先还原 A，再处理 B；
- 无可避让：松手复位；
- 性能：12列/50卡单帧计算 ≤ 16–20ms；交互无闪烁。