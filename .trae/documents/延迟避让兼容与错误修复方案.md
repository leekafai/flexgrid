## 问题分析
- 报错来源：在鼠标抬起后附加的观察器会在后续 style 变动时调用 `getModelPos`；当前实现使用 `draggedCard.value!` 非空断言，拖拽结束后该值为 `null`，导致 `Cannot read properties of null (reading 'position')`。位置：
  - `src/components/BentoGrid.vue:480` 与 `src/components/BentoGrid.vue:1149` 的 `attachPlacementObserver` 第三个参数。
- 交互影响：延迟避让会让卡片短暂重叠，这是预期副作用；但应避免因为延迟导致的空指针错误与过度遮挡。

## 修复与兼容策略
### 1) 观察器空值防护（必做）
- 将 `getModelPos` 改为空安全：
  - 由 `() => ({ x: draggedCard.value!.position.x, y: draggedCard.value!.position.y })`
  - 改为 `() => draggedCard.value ? { x: draggedCard.value.position.x, y: draggedCard.value.position.y } : null`
- 修改位置：
  - `src/components/BentoGrid.vue:480`
  - `src/components/BentoGrid.vue:1149`
- 说明：`debugPlacementObserver` 已支持 `null` 返回值并仅记录日志，不会再触发异常。

### 2) 重叠视觉兼容（可选，默认启用）
- 在延迟期间不触发避让时：确保拖拽卡片层级在最上方（已有样式 `z-index: 999`）；保持不移动其他卡片，避免布局抖动。
- 同时保持当前插件逻辑的“将阴影区域标记为占用”，避免被避让卡片被移动回阴影内。

### 3) 强避让阈值（可选，默认关闭）
- 新增可选配置 `avoidanceForceRatio`（0–1，默认 `0`）用于极端遮挡：当交叠面积占比超过阈值，即使未达到 `avoidanceDelayMs` 也触发避让。
- 位置：在 `src/plugins/avoidance/index.ts` 的待避让排序前插入判定；仅对面积占比高的卡片生效，避免“路过”触发。

### 4) 事件清理健壮性（建议）
- 拖拽结束前后继续调用现有 `_overlapStartTs.clear()` 与 `lastShadow` 更新，避免历史覆盖数据影响下一次拖拽。
- 保留 `onDragEnd` 的清理逻辑即可，无需新增接口。

## 验证步骤
- 启动开发服务后进行两类操作：
  - 长距离快速拖动穿过卡片：不再立即避让，被经过卡片不移动，拖拽卡片在上层显示，无报错。
  - 在某卡片上停留 ≥ `avoidanceDelayMs`：触发避让并产生移动计划，布局稳定。
- 控制台验证：不再出现 `Cannot read properties of null (reading 'position')`。

## 变更范围与最小化
- 必做改动仅涉及两处空值防护；其余兼容项为插件内部小范围条件判定，均为向后兼容、可配置。

## 配置示例
- `BentoGrid`：`<BentoGrid :avoidanceDelayMs="150" />`（已支持）
- 可选：`<BentoGrid :avoidanceDelayMs="150" :avoidanceForceRatio="0.6" />`（若选择开启强避让阈值）

请确认是否按上述方案执行：默认先应用“观察器空值防护”，并保持延迟避让；若需要强避让阈值，请告知期望占比参数。