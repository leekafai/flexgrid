## 问题诊断
- 阴影短暂停留在卡片上时触发了避让，但随着鼠标继续移动，避让卡片被释放返回原位；在此瞬间若放置另一张卡，会与已恢复位置的卡重叠。
- 根因：避让计算是“局部、瞬时、逐帧”的；缺少拖拽期的“全局一致状态”，没有把“尚未落定”的移动当成暂时占用来约束之后的计算。

## 目标
- 在拖拽开始到松手之间，维护一份全局、连贯的“临时占用图（Reservation Map）”，把已避让的卡片位置视为“已预留”，避免随后计算把它们当作可用空间，从而产生回退或重叠。
- 始终保证：拖拽期间网格中“非拖拽卡片 + 已预留位置”不重叠；落点时要么一次性提交预留，要么整体回滚。

## 核心架构
- 新增 DragAvoidanceSession（会话管理）在插件内部：
  - `reservations: Map<cardId,{x,y,w,h}>` 临时预留位置（含已避让目标）
  - `originals: Map<cardId,{x,y}>` 记录避让前位置，支持回滚
  - `shadow: { gridRect, pxRect, areaKey }` 当前阴影信息与变化阈值
  - `coveredIds: Set<string>` 当前阴影覆盖的卡片集合
  - `lastPlan: Map<cardId,{x,y}>` 最近一次下发的移动（用于 DOM diff）
  - `hysteresis: { pixelThreshold:5, holdMs:300 }` 阈值与保留期控制，避免抖动

## 会话流程
- 拖拽开始（onDragStart）：
  - 初始化会话，清空 `reservations/originals/lastPlan`，记下初始阴影与覆盖集合
- 拖拽更新（onDragUpdate，RAF内、阴影驱动）：
  1) 阴影变化检测：像素位移<5px且 `areaKey/coveredIds` 未变 → 跳过
  2) 构建占用图：
     - 基础占用：所有非拖拽卡片的现位
     - 预留占用：`reservations` 中的已避让位置（用作不可用）
  3) 仅对 `coveredIds` 参与避让，按与阴影的重叠面积降序取“一张目标卡”；
  4) 四向检查：先做单步（下→右→上→左），若无则做限深 BFS（方向优先，下→右→上→左，限定层/节点保证<16ms）；
  5) 若找到位置：
     - 若尚无预留，则将该卡记录到 `originals`（若未存在）并写入 `reservations`；
     - 生成移动计划（只包含变更的卡，做 DOM diff），更新 `lastPlan`
  6) 若找不到位置：
     - 不避让；保持现有 `reservations` 不变（避免回退）
- 区域切换：
  - 当 `coveredIds` 与上一帧发生变化并移出原目标卡时，释放该卡的预留并生成“还原移动”，保证单卡避让锁；再按新覆盖卡重算与预留。
- 拖拽结束（onBeforeDrop→onDragEnd）：
  - 先进行一次完整避让尝试；若拖拽卡目标仍冲突→回滚所有 `reservations`（用 `originals`），拖拽卡复位；
  - 若无冲突→将 `reservations` 一次性提交为真实位置，清理会话。

## 算法细节
- 占用图：二维数组/位集；预留位置按卡片尺寸写入 1 值；
- `canPlace` 修正：越界行视为可扩展空行，允许向下探测；
- BFS 限制：最大节点数/层深（如 400/20），早停于首个可容纳位置；
- 选择策略：重叠面积最大优先，同面积选位移成本最小；始终只选一张卡。

## 稳定性与阈值
- Hysteresis：对已预留的卡，设置最短“保持期”（如 300ms）或“阴影实质离开”后才释放，避免来回鬼畜；
- 三要素节流：像素位移<5px + 区域键相同 + 覆盖集合相同 → 不重算；
- DOM diff：仅对位置发生变化的卡执行 `moveCard`，减少抖动。

## 集成点
- 插件：实现 DragAvoidanceSession，并在 `onDragStart/onDragUpdate/onBeforeDrop/onDragEnd` 维护 `reservations/originals/lastPlan` 与下发计划；
- 网格层：保持现有调用，但应用计划时只移动发生变化的卡；落点时先避让再“提交或回滚”。

## 测试与验收
- 场景：
  - 阴影从卡A转到卡B：先还原A，再避让B；不出现“消失/重叠”。
  - 阴影覆盖有下/右空间：优先避让；空间不足时不避让；落点仍冲突则复位拖拽卡。
  - 阴影在同格内微动：不重复计算、不重复 DOM 操作。
  - 大规模：12列、50卡，单帧计算≤16–20ms。
- 验收标准：拖拽期间保持全局不重叠；落点一致性；动效平滑且稳定。