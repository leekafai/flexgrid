## 问题诊断
- 触发源应是阴影，而不是鼠标。当前在 `dragover/dragenter` 路径未做阴影阈值判断，导致阴影不变也重复分发避让。
- 插件节流只比较阴影像素与区域键，但网格层仍然在不同事件路径重复调用，造成“已避让卡片在阴影不变时仍发生变化”。

## 修复方案（代码层）
- 网格层统一阴影阈值节流
  1) 抽取 `shouldRecomputeShadow(prev, dropRect, cardUnits, unit, gap, pxThreshold=5)` 返回布尔：像素位移≥5 或区域键变更才允许重算。
  2) 在 `handleMouseMove/handleDragOver/handleDragEnter` 三处调用前统一判断，未满足则直接 `return`。
  3) 维护 `lastShadow`（left/top/areaKey）在拖拽开始清零、每次通过判断后更新。
- 插件保持单次避让持有
  1) 仅在阴影变化时重算；同一区域不释放已预留、不做新移动；
  2) 区域切换时先还原上一个目标卡（释放预留），再对新的覆盖卡做一次避让并写入预留；
  3) 继续使用预留占用叠加到占用图，避免再次把预留位置当空位。
- 四向检查与性能
  - 单步下→右→上→左；不可用则限深 BFS（允许向下扩展“空行”），最大节点/层数限制，保持单帧≤16–20ms。
- 落点一致性
  - `onBeforeDrop` 再次尝试避让；若仍冲突则回滚所有预留并平滑复位拖拽卡（≤300ms）。

## 端到端验证（Puppeteer）
- 场景1：阴影静止（鼠标轻微抖动）
  - 进入 `http://localhost:5173/test-p-grid`，缓慢在卡 `#5` 区域内移动指针但不超过 5px，确认没有新避让动作（通过日志或快照对比）。
- 场景2：阴影切换覆盖对象
  - 将拖拽卡从 `#6` 移到 `#5` 区域：先避让 `#5`；再移到 `#4` 区域：先还原 `#5` 再避让 `#4`；确认始终只移动一张卡。
- 场景3：无可用空间落点复位
  - 将拖拽卡移至无可避让位置并松手：确认拖拽卡复位，其他卡还原，最终无重叠。
- 每步截图与 `console.log` 输出 `areaKey/lastShadow/activeTarget/reservations`，确保行为符合预期。

## 交付步骤
1) 在 `BentoGrid.vue` 提取并应用统一的阴影阈值判断到三处事件路径。
2) 在插件中保持单次避让持有与区域切换还原（已部分实现，补全释放条件与日志）。
3) 加入 Puppeteer 脚本并运行上述三类场景，提交截图与日志。
4) 根据结果微调阈值（默认 5px）与 BFS 限制，确保稳定与性能。