## 问题根因
- 每帧都用 `getBoundingClientRect` 重新测量被拖卡片尺寸，而该元素在拖拽时应用了 `transform: scale(1.02)`，导致测得尺寸被缩放。
- 测得的增大尺寸再次用于设置拖拽影子宽高，同时继续应用缩放，形成持续增大的反馈。

## 解决方案
1. 仅在拖拽开始时测量一次尺寸：使用 `el.offsetWidth/offsetHeight`（不受 `transform` 影响），缓存为 `dragSize`。
2. 拖拽过程中不再更新 `dragSize`，始终使用初始未缩放的尺寸。
3. 拖拽影子移除缩放：`getDragStyles` 将 `transform` 设置为 `none`，避免任何视觉尺寸乘法。
4. 预估位置矩形使用 `dragSize` 宽高，保持与原卡片一致。

## 变更范围
- `src/composables/useDragAndDrop.ts`：
  - `startDrag` 改为用 `offsetWidth/offsetHeight` 设置 `dragSize`
  - 移除 `updateDrag` 中对 `dragSize` 的赋值
  - `getDragStyles` 去掉 `scale(1.02)`，改为 `transform: 'none'`
  - `dropRect` 宽高取 `dragSize`（fallback 到 units 计算）

## 验证
- 在 `/test` 拖拽不同大小卡片，影子尺寸保持不变且与原卡片一致；不会随拖动而增大。
- 第一行拖拽到下方行仍可插入（此前已实现基于指针Y的插入逻辑）。