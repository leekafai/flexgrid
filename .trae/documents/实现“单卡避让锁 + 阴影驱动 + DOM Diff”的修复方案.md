## 问题总结
- 同一目标区域反复避让导致视觉异常；区域切换时未先还原旧目标，出现“卡片消失/重叠”。
- 需要严格遵循：仅避让阴影覆盖的卡片、一次只移动一个卡片、阴影不变不重复计算、无可用空间则不避让并在落点时复位拖拽卡。

## 目标行为
- 阴影覆盖卡片时：检查上/下/左/右是否存在可容纳空间，有则对“重叠面积最大”的那一张执行避让；否则不避让。
- 单卡避让锁：同一时间仅维护一个被避让目标；当阴影转移到另一张卡片，先还原旧目标再处理新目标。
- 阴影变更检测与阈值：阴影像素位移 < 5px（或网格坐标未变）视为无变化，不计算、不下发 DOM 操作。
- 落点处理：若无法避让且用户松手，拖拽卡平滑复位到起始位置（≤300ms）。
- DOM Diff：仅当本次移动与上次不同才执行 `moveCard`，避免不必要重排/重绘。

## 实现细节
- 插件（`src/plugins/avoidance/index.ts`）
  1) 状态新增
     - `prevShadowRect`: 上次阴影网格矩形与像素位置（用于阈值判断）
     - `activeTarget`: 单卡避让锁 `{ cardId, areaKey, origPos, movedPos }`
     - `lastMove`: 上次对该卡片的移动 `{ cardId -> { x, y } }`
  2) 阴影变化检测
     - 比较 `dropRect` 与 `prevShadowRect` 的像素位移（<5px视为无变化）与网格矩形是否变化；无变化则 `return null`。
  3) 仅对覆盖卡片计算
     - 通过 AABB 找出 `coveredCards`，按与阴影重叠面积降序排序，取第一张作为候选。
  4) 四方向可用空间检查
     - 先做单步方向探测（上/下/左/右）；若都不可用，启动限深 BFS（方向优先，上→下→左→右，限制节点/层数确保性能）。
     - 无可用空间时 `return null`。
  5) 单卡锁与区域切换
     - 若候选与 `activeTarget` 不同，返回计划前添加对旧目标的还原移动（`origPos`），并设置新 `activeTarget`。
     - 若候选与 `activeTarget` 相同且目标坐标未变，跳过；若坐标变化则生成新移动。
  6) DOM Diff
     - 与 `lastMove` 比较；坐标一致则跳过移动。仅返回变化的移动集合。
  7) 落点前（`onBeforeDrop`）
     - 复用上述逻辑，但不受阴影像素阈值限制，确保最终避让或还原必定执行。
- 网格层（`src/components/BentoGrid.vue`）
  1) 拖拽开始：记录 `dragOriginPos`。
  2) 拖拽移动：构造 `ctx`，在 RAF 流程中仅当阴影像素变化 ≥5px 或网格矩形变更时才分发 `onDragUpdate`；应用插件返回计划时执行 DOM Diff（只移动变化卡）。
  3) 鼠标松开/`drop`：先检测目标坐标是否碰撞；若碰撞则调用 `onBeforeDrop` 尝试避让；仍碰撞则将拖拽卡复位到 `dragOriginPos` 且更新覆盖层动画；否则正常落点并应用最终计划；之后分发 `onDragEnd` 清理状态。

## 性能与动画
- 所有计算在 RAF 中运行，避免卡顿。
- 像素阈值 5px；避让动画时间 200–300ms，缓动 `cubic-bezier(.22,1,.36,1)`；不使用 `left/top` 过渡以避免错误来源动画。

## 验收用例
- 阴影覆盖单卡/多卡：仅阴影下最大重叠卡避让；无空间不避让；落点复位生效。
- 阴影不变时不重复计算、不重复 DOM 操作。
- 阴影区域从 A 移到 B：先还原 A，再处理 B；不会出现“卡片消失”。
- 50 卡、12 列：平均计算 ≤ 20ms；可迭代至 ≤ 16ms。

## 交付
- 更新插件与网格集成，补充单元测试：阴影节流、单卡锁、区域切换还原、DOM Diff 与复位逻辑。